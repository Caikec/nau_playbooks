## Nginx configuration for any richie site
{% macro generate(site) %}
# {{ ansible_managed }}

events {}

http {

    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format compression '$http_x_forwarded_for - $remote_addr - $remote_user [$time_local]  '
        '"$request" $status $body_bytes_sent $request_time '
        '"$http_referer" "$http_user_agent"';

    # Enable gzip compression.
    # Default: off
    gzip on;

    # Compression level (1-9).
    # 5 is a perfect compromise between size and CPU usage, offering about
    # 75% reduction for most ASCII files (almost identical to level 9).
    # Default: 1
    gzip_comp_level    5;

    # Don't compress anything that's already small and unlikely to shrink much
    # if at all (the default is 20 bytes, which is bad as that usually leads to
    # larger files after gzipping).
    # Default: 20
    gzip_min_length    256;

    # Compress data even for clients that are connecting to us via proxies,
    # identified by the "Via" header (required for CloudFront).
    # Default: off
    gzip_proxied       any;

    # Tell proxies to cache both the gzipped and regular version of a resource
    # whenever the client's Accept-Encoding capabilities header varies;
    # Avoids the issue where a non-gzip capable client (which is extremely rare
    # today) would display gibberish if their proxy gave them the gzipped version.
    # Default: off
    gzip_vary          on;

    # Compress all output labeled with one of the following MIME-types.
    # text/html is always compressed by gzip module.
    # Default: text/html
    gzip_types
        application/atom+xml
        application/javascript
        application/json
        application/ld+json
        application/manifest+json
        application/rss+xml
        application/vnd.geo+json
        application/vnd.ms-fontobject
        application/x-font-ttf
        application/x-web-app-manifest+json
        application/xhtml+xml
        application/xml
        font/opentype
        image/bmp
        image/svg+xml
        image/x-icon
        text/cache-manifest
        text/css
        text/plain
        text/vcard
        text/vnd.rim.location.xloc
        text/vtt
        text/x-component
        text/x-cross-domain-policy;

    # This should be turned on if you are going to have pre-compressed copies (.gz) of
    # static files available. If not it should be left off as it will cause extra I/O
    # for the check. It is best if you enable this in a location{} block for
    # a specific directory, or on an individual server{} level.
    # gzip_static on;


{% if richie_nginx_enable_https | default(true) %}
    ssl_protocols {{ NGINX_SSL_PROTOCOLS }};
    ssl_ciphers {{ NGINX_SSL_CIPHERS }};
    ssl_prefer_server_ciphers on;

    # SSL intermediate configuration from https://mozilla.github.io/server-side-tls/ssl-config-generator/
    ssl_certificate /etc/ssl/certs/certificate.crt.pem;
    ssl_certificate_key /etc/ssl/certs/certificate.key.pem;
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
{% endif %}

    client_max_body_size 100M;
    charset utf-8;

    server {
{% if richie_nginx_enable_https | default(true) %}
        listen [::]:443 ssl {{ ' proxy_protocol' if richie_nginx_proxy_protocol else ''}}{{ ' http2' if richie_nginx_http2 is defined and richie_nginx_http2 else ''}};
        listen 443 ssl {{ ' proxy_protocol' if richie_nginx_proxy_protocol else ''}}{{ ' http2' if richie_nginx_http2 is defined and richie_nginx_http2 else ''}};
        {% if richie_alternative_nginx_https_port is defined %}
        listen {{ richie_alternative_nginx_https_port }} ssl; # no proxy protocol so we can verify the application during deployment.
        {% endif %}
{% endif %}
        listen 80 {{ ' proxy_protocol' if richie_nginx_proxy_protocol else ''}}{{ ' http2' if richie_nginx_http2 is defined and richie_nginx_http2 else ''}};
        server_name _;

{% if richie_nginx_enable_https | default(true) %}
        # request the browser to use SSL for all connections
        add_header Strict-Transport-Security "max-age={{ richie_nginx_hsts_max_age }}; includeSubDomains; preload" always;
{% endif %}
        add_header X-Backend-Server $hostname always;
        add_header X-Frame-Options "SAMEORIGIN";
        add_header X-XSS-Protection "1; mode=block";


{% if richie_nginx_admin_access_trusted_ip_cidrs is defined %}
        set_real_ip_from {{ richie_nginx_admin_access_trusted_ip_cidrs }};
{% endif %}
{% if richie_nginx_proxy_protocol %}
        real_ip_header proxy_protocol;
{% endif %}
        access_log /var/log/nginx/access.log compression;

{% if richie_nginx_force_https | default(true) %}
        # force TLS
        if ($scheme = http) {
            return 301 https://$server_name$request_uri;
        }
{% endif %}


{% if richie_nginx_auth_basic_enable is defined and richie_nginx_auth_basic_enable %}
        auth_basic_user_file  {{ richie_nginx_auth_basic_user_file }};
{% endif %}

{% if richie_nginx_enable_s3_maintenance is defined and richie_nginx_enable_s3_maintenance %}
        error_page 502 @maintenance;
        error_page 500 @maintenance;
        error_page 504 @maintenance;

        location @maintenance {
            rewrite  ^(.*) {{ richie_nginx_enable_s3_maintenance_file }} break;
            proxy_http_version     1.1;
            proxy_set_header       Host {{ richie_nginx_enable_s3_maintenance_host }};
            proxy_set_header       Authorization '';
            proxy_hide_header      x-amz-id-2;
            proxy_hide_header      x-amz-request-id;
            proxy_hide_header      Set-Cookie;
            proxy_ignore_headers   "Set-Cookie";
            proxy_buffering        off;
            proxy_intercept_errors on;
            proxy_pass {{ richie_nginx_enable_s3_maintenance_url }};
        }
{% endif %}

        open_file_cache          max=2000 inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;

        location = /favicon.ico {
            log_not_found off;
            access_log off;
        }

        # Static assets collected during docker image build.
        # Are cached by the client browser for 30 days.
        # They have hash on its URLs, so there isn't a problem of the client view the old files.
        location /static/ {
            alias /data/static/;
            expires           30d;
        }

        # The Richie API `/api/v1.0/course-runs-sync/` can not have basic authentication,
        # because the message already uses the HTTP Header Authorization for hash-based message 
        # authentication code - SIG-HMAC-SHA256
        location /api/ {
            auth_basic off;
            try_files /no-existing-directory @proxy; # proxy to the richie app
        }

{% if richie_nginx_admin_access_locations is defined %}
{% for loc in richie_nginx_admin_access_locations %}

        location ~ {{ loc.path }} {
            {% for cidr in loc.cidrs %}
            allow {{ cidr }};
            {% endfor %}
            deny all;
            try_files /no-existing-directory @proxy; # proxy to the richie app
        }
 
{% endfor %}
{% endif %}

        # Any other URL, should be proxied
        location / {
{% if richie_nginx_auth_basic_enable is defined and richie_nginx_auth_basic_enable %}
            auth_basic "Restricted";
{% endif %}
            try_files /no-existing-directory @proxy; # proxy to the richie app
        }

        # Named location `@proxy`to be reference on previous statements
        location @proxy {
            proxy_pass http://{{ site }}_app:8000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

    }

    # server to monitor nginx
    server {
        listen {{ NAU_NGINX_STATUS_SERVER_PORT | default('80') }};
        server_name {{ NAU_NGINX_STATUS_SERVER_NAME | default('nginx_status_server') }};
        location /nginx_status {
            stub_status on;
            access_log off;
        }
    }

{% for redirect in virtual_hosts_redirections %}
    # redirect {{ redirect.server_name }}
    server {
        listen [::]:443 ssl {{ ' proxy_protocol' if richie_nginx_proxy_protocol else ''}};
        listen 443 ssl {{ ' proxy_protocol' if richie_nginx_proxy_protocol else ''}};
        server_name {{ redirect.server_name }};
        real_ip_header {{ ' proxy_protocol' if richie_nginx_proxy_protocol else ''}};
        access_log /var/log/nginx/access.log compression;
        return 301 {{ redirect.destination }}$request_uri;
    }

{% endfor %}
}
{% endmacro %}
